// Generated automatically from ./src/wren_core.wren. Do not edit.
static const char* coreModuleSource =
"class Bool {\n"
"  [key] { null }\n"
"  map(f) { List.new() }\n"
"  count { 0 }\n"
"}\n"
"class Fiber {}\n"
"class Fn {}\n"
"class Num {}\n"
"class Null {\n"
"  [key] { null }\n"
"  map(f) { List.new() }\n"
"  count { 0 }\n"
"}\n"
"class Sequence {\n"
"  all(f) {\n"
"    var result = true\n"
"    for (element in this) {\n"
"      result = f.call(element)\n"
"      if (!result) return result\n"
"    }\n"
"    return result\n"
"  }\n"
"  any(f) {\n"
"    var result = false\n"
"    for (element in this) {\n"
"      result = f.call(element)\n"
"      if (result) return result\n"
"    }\n"
"    return result\n"
"  }\n"
"  contains(element) {\n"
"    for (item in this) {\n"
"      if (element == item) return true\n"
"    }\n"
"    return false\n"
"  }\n"
"  count {\n"
"    var result = 0\n"
"    for (element in this) {\n"
"      result = result + 1\n"
"    }\n"
"    return result\n"
"  }\n"
"  count(f) {\n"
"    var result = 0\n"
"    for (element in this) {\n"
"      if (f.call(element)) result = result + 1\n"
"    }\n"
"    return result\n"
"  }\n"
"  each(f) {\n"
"    for (element in this) {\n"
"      f.call(element)\n"
"    }\n"
"  }\n"
"  isEmpty { iterate(null) ? false : true }\n"
"  map(transformation) { MapSequence.new(this, transformation) }\n"
"  skip(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    return SkipSequence.new(this, count)\n"
"  }\n"
"  take(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    return TakeSequence.new(this, count)\n"
"  }\n"
"  where(predicate) { WhereSequence.new(this, predicate) }\n"
"  reduce(acc, f) {\n"
"    for (element in this) {\n"
"      acc = f.call(acc, element)\n"
"    }\n"
"    return acc\n"
"  }\n"
"  reduce(f) {\n"
"    var iter = iterate(null)\n"
"    if (!iter) Fiber.abort(\"Can't reduce an empty sequence.\")\n"
"    var result = iteratorValue(iter)\n"
"    while (iter = iterate(iter)) {\n"
"      result = f.call(result, iteratorValue(iter))\n"
"    }\n"
"    return result\n"
"  }\n"
"  join() { join(\"\") }\n"
"  join(sep) {\n"
"    var first = true\n"
"    var result = \"\"\n"
"    for (element in this) {\n"
"      if (!first) result = result + sep\n"
"      first = false\n"
"      result = result + element.toString\n"
"    }\n"
"    return result\n"
"  }\n"
"  joinInt_() {\n"
"    var res = \"\"\n"
"    for (element in this) {\n"
"      if (element.type != Bool || element) res = res + \"\" + element.toString\n"
"    }\n"
"    return res\n"
"  }\n"
"  slice(start) { slice(start, -1) }\n"
"  slice(start, end) {\n"
"    var list = toList\n"
"    if (end < 0) {\n"
"      end = list.count\n"
"    }\n"
"    var result = []\n"
"    for (index in start...end) {\n"
"      result.add(list[index])\n"
"    }\n"
"    return result\n"
"  }\n"
"  toList {\n"
"    var result = List.new()\n"
"    for (element in this) {\n"
"      result.add(element)\n"
"    }\n"
"    return result\n"
"  }\n"
"}\n"
"class MapSequence is Sequence {\n"
"  construct new(sequence, fn) {\n"
"    _sequence = sequence\n"
"    _fn = fn\n"
"  }\n"
"  iterate(iterator) { _sequence.iterate(iterator) }\n"
"  iteratorValue(iterator) { _fn.call(_sequence.iteratorValue(iterator)) }\n"
"  toString { join(\"\") }\n"
"}\n"
"class SkipSequence is Sequence {\n"
"  construct new(sequence, count) {\n"
"    _sequence = sequence\n"
"    _count = count\n"
"  }\n"
"  iterate(iterator) {\n"
"    if (iterator) {\n"
"      return _sequence.iterate(iterator)\n"
"    } else {\n"
"      iterator = _sequence.iterate(iterator)\n"
"      var count = _count\n"
"      while (count > 0 && iterator) {\n"
"        iterator = _sequence.iterate(iterator)\n"
"        count = count - 1\n"
"      }\n"
"      return iterator\n"
"    }\n"
"  }\n"
"  iteratorValue(iterator) { _sequence.iteratorValue(iterator) }\n"
"}\n"
"class TakeSequence is Sequence {\n"
"  construct new(sequence, count) {\n"
"    _sequence = sequence\n"
"    _count = count\n"
"  }\n"
"  iterate(iterator) {\n"
"    if (!iterator) _taken = 1 else _taken = _taken + 1\n"
"    return _taken > _count ? null : _sequence.iterate(iterator)\n"
"  }\n"
"  iteratorValue(iterator) { _sequence.iteratorValue(iterator) }\n"
"}\n"
"class WhereSequence is Sequence {\n"
"  construct new(sequence, fn) {\n"
"    _sequence = sequence\n"
"    _fn = fn\n"
"  }\n"
"  iterate(iterator) {\n"
"    while (iterator = _sequence.iterate(iterator)) {\n"
"      if (_fn.call(_sequence.iteratorValue(iterator))) break\n"
"    }\n"
"    return iterator\n"
"  }\n"
"  iteratorValue(iterator) { _sequence.iteratorValue(iterator) }\n"
"}\n"
"class String is Sequence {\n"
"  bytes { StringByteSequence.new(this) }\n"
"  codePoints { StringCodePointSequence.new(this) }\n"
"  split(delimiter) {\n"
"    if (!(delimiter is String) || delimiter.isEmpty) {\n"
"      Fiber.abort(\"Delimiter must be a non-empty string.\")\n"
"    }\n"
"    var result = []\n"
"    var last = 0\n"
"    var index = 0\n"
"    var delimSize = delimiter.byteCount_\n"
"    var size = byteCount_\n"
"    while (last < size && (index = indexOf(delimiter, last)) != -1) {\n"
"      result.add(this[last...index])\n"
"      last = index + delimSize\n"
"    }\n"
"    if (last < size) {\n"
"      result.add(this[last..-1])\n"
"    } else {\n"
"      result.add(\"\")\n"
"    }\n"
"    return result\n"
"  }\n"
"  replace(from, to) {\n"
"    if (!(from is String) || from.isEmpty) {\n"
"      Fiber.abort(\"From must be a non-empty string.\")\n"
"    } else if (!(to is String)) {\n"
"      Fiber.abort(\"To must be a string.\")\n"
"    }\n"
"    var result = \"\"\n"
"    var last = 0\n"
"    var index = 0\n"
"    var fromSize = from.byteCount_\n"
"    var size = byteCount_\n"
"    while (last < size && (index = indexOf(from, last)) != -1) {\n"
"      result = result + this[last...index] + to\n"
"      last = index + fromSize\n"
"    }\n"
"    if (last < size) result = result + this[last..-1]\n"
"    return result\n"
"  }\n"
"  trim() { trim_(\"\\t\\r\\n \", true, true) }\n"
"  trim(chars) { trim_(chars, true, true) }\n"
"  trimEnd() { trim_(\"\\t\\r\\n \", false, true) }\n"
"  trimEnd(chars) { trim_(chars, false, true) }\n"
"  trimStart() { trim_(\"\\t\\r\\n \", true, false) }\n"
"  trimStart(chars) { trim_(chars, true, false) }\n"
"  trim_(chars, trimStart, trimEnd) {\n"
"    if (!(chars is String)) {\n"
"      Fiber.abort(\"Characters must be a string.\")\n"
"    }\n"
"    var codePoints = chars.codePoints.toList\n"
"    var start\n"
"    if (trimStart) {\n"
"      while (start = iterate(start)) {\n"
"        if (!codePoints.contains(codePointAt_(start))) break\n"
"      }\n"
"      if (start == false) return \"\"\n"
"    } else {\n"
"      start = 0\n"
"    }\n"
"    var end\n"
"    if (trimEnd) {\n"
"      end = byteCount_ - 1\n"
"      while (end >= start) {\n"
"        var codePoint = codePointAt_(end)\n"
"        if (codePoint != -1 && !codePoints.contains(codePoint)) break\n"
"        end = end - 1\n"
"      }\n"
"      if (end < start) return \"\"\n"
"    } else {\n"
"      end = -1\n"
"    }\n"
"    return this[start..end]\n"
"  }\n"
"  *(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    var result = \"\"\n"
"    for (i in 0...count) {\n"
"      result = result + this\n"
"    }\n"
"    return result\n"
"  }\n"
"  lower {\n"
"    var output = \"\"\n"
"    for (c in codePoints) {\n"
"        if ((c >= 65 && c <= 90) || (c >= 192 && c <= 214) || (c >= 216 && c <= 222)) {\n"
"            c = c + 32\n"
"        }\n"
"        output = output + String.fromCodePoint(c)\n"
"    }\n"
"    return output\n"
"  }\n"
"  upper {\n"
"    var output = \"\"\n"
"    for (c in codePoints) {\n"
"        if ((c >= 97 && c <= 122) || (c >= 224 && c <= 246) || (c >= 248 && c <= 254)) {\n"
"            c = c - 32\n"
"        }\n"
"        output = output + String.fromCodePoint(c)\n"
"    }\n"
"    return output\n"
"  }\n"
"  safe {\n"
"    var output = \"\"\n"
"    for (c in codePoints) {\n"
"        if (c == 38) {\n"
"            output = output + \"&amp;\"\n"
"        } else if (c == 60) {\n"
"            output = output + \"&lt;\"\n"
"        } else if (c == 62) {\n"
"            output = output + \"&gt;\"\n"
"        } else if (c == 34) {\n"
"            output = output + \"&quot;\"\n"
"        } else if (c == 39) {\n"
"            output = output + \"&apos;\"\n"
"        } else {\n"
"            output = output + String.fromCodePoint(c)\n"
"        }\n"
"    }\n"
"    return output\n"
"  }\n"
"}\n"
"class StringByteSequence is Sequence {\n"
"  construct new(string) {\n"
"    _string = string\n"
"  }\n"
"  [index] { _string.byteAt_(index) }\n"
"  iterate(iterator) { _string.iterateByte_(iterator) }\n"
"  iteratorValue(iterator) { _string.byteAt_(iterator) }\n"
"  count { _string.byteCount_ }\n"
"}\n"
"class StringCodePointSequence is Sequence {\n"
"  construct new(string) {\n"
"    _string = string\n"
"  }\n"
"  [index] { _string.codePointAt_(index) }\n"
"  iterate(iterator) { _string.iterate(iterator) }\n"
"  iteratorValue(iterator) { _string.codePointAt_(iterator) }\n"
"  count { _string.count }\n"
"}\n"
"class List is Sequence {\n"
"  addAll(other) {\n"
"    for (element in other) {\n"
"      add(element)\n"
"    }\n"
"    return other\n"
"  }\n"
"  sort() { sort {|low, high| low < high } }\n"
"  sort(comparer) {\n"
"    if (!(comparer is Fn)) {\n"
"      Fiber.abort(\"Comparer must be a function.\")\n"
"    }\n"
"    quicksort_(0, count - 1, comparer)\n"
"    return this\n"
"  }\n"
"  quicksort_(low, high, comparer) {\n"
"    if (low < high) {\n"
"      var p = partition_(low, high, comparer)\n"
"      quicksort_(low, p - 1, comparer)\n"
"      quicksort_(p + 1, high, comparer)\n"
"    }\n"
"  }\n"
"  partition_(low, high, comparer) {\n"
"    var p = this[high]\n"
"    var i = low - 1\n"
"    for (j in low..(high-1)) {\n"
"      if (comparer.call(this[j], p)) {\n"
"        i = i + 1\n"
"        var t = this[i]\n"
"        this[i] = this[j]\n"
"        this[j] = t\n"
"      }\n"
"    }\n"
"    var t = this[i+1]\n"
"    this[i+1] = this[high]\n"
"    this[high] = t\n"
"    return i+1\n"
"  }\n"
"  toString { \"[%(join(\", \"))]\" }\n"
"  +(other) {\n"
"    var result = this[0..-1]\n"
"    for (element in other) {\n"
"      result.add(element)\n"
"    }\n"
"    return result\n"
"  }\n"
"  *(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    var result = []\n"
"    for (i in 0...count) {\n"
"      result.addAll(this)\n"
"    }\n"
"    return result\n"
"  }\n"
"  first { count > 0 ? this[0] : null }\n"
"}\n"
"class Map is Sequence {\n"
"  keys { MapKeySequence.new(this) }\n"
"  values { MapValueSequence.new(this) }\n"
"  toString {\n"
"    var first = true\n"
"    var result = \"{\"\n"
"    for (key in keys) {\n"
"      if (!first) result = result + \", \"\n"
"      first = false\n"
"      result = result + \"%(key): %(this[key])\"\n"
"    }\n"
"    return result + \"}\"\n"
"  }\n"
"  iteratorValue(iterator) {\n"
"    return MapEntry.new(\n"
"        keyIteratorValue_(iterator),\n"
"        valueIteratorValue_(iterator))\n"
"  }\n"
"}\n"
"class MapEntry {\n"
"  construct new(key, value) {\n"
"    _key = key\n"
"    _value = value\n"
"  }\n"
"  key { _key }\n"
"  value { _value }\n"
"  toString { \"%(_key):%(_value)\" }\n"
"}\n"
"class MapKeySequence is Sequence {\n"
"  construct new(map) {\n"
"    _map = map\n"
"  }\n"
"  iterate(n) { _map.iterate(n) }\n"
"  iteratorValue(iterator) { _map.keyIteratorValue_(iterator) }\n"
"}\n"
"class MapValueSequence is Sequence {\n"
"  construct new(map) {\n"
"    _map = map\n"
"  }\n"
"  iterate(n) { _map.iterate(n) }\n"
"  iteratorValue(iterator) { _map.valueIteratorValue_(iterator) }\n"
"}\n"
"class Range is Sequence {}\n"
"class System {\n"
"  static print() {\n"
"  }\n"
"  static print(obj) {\n"
"    writeObject_(obj)\n"
"    return obj\n"
"  }\n"
"  static printAll(sequence) {\n"
"    for (object in sequence) writeObject_(object)\n"
"  }\n"
"  static write(obj) {\n"
"    writeObject_(obj)\n"
"    return obj\n"
"  }\n"
"  static writeAll(sequence) {\n"
"    for (object in sequence) writeObject_(object)\n"
"  }\n"
"  static writeObject_(obj) {\n"
"    var string = obj.toString\n"
"    if (string is String) {\n"
"      writeString_(string)\n"
"    } else {\n"
"      writeString_(\"[invalid toString]\")\n"
"    }\n"
"  }\n"
"}\n"
"class ClassAttributes {\n"
"  self { _attributes }\n"
"  methods { _methods }\n"
"  construct new(attributes, methods) {\n"
"    _attributes = attributes\n"
"    _methods = methods\n"
"  }\n"
"  toString { \"attributes:%(_attributes) methods:%(_methods)\" }\n"
"}\n"
"class Query {\n"
"  construct new() {}\n"
"  static fromString(string, params) { Query.new().query_(string, params) }\n"
"  static fetchFromString(string, params) { Query.new().fetch_(string, params) }\n"
"  query { query_(this, []) }\n"
"  query() { query_(this, []) }\n"
"  query(param) { query_(this, param is List ? param : [param]) }\n"
"  query(p1, p2) { query_(this, [p1, p2]) }\n"
"  query(p1, p2, p3) { query_(this, [p1, p2, p3]) }\n"
"  fetch { fetch_(this, []) }\n"
"  fetch() { fetch_(this, []) }\n"
"  fetch(param) { fetch_(this, param is List ? param : [param]) }\n"
"  fetch(p1, p2) { fetch_(this, [p1, p2]) }\n"
"  fetch(p1, p2, p3) { fetch_(this, [p1, p2, p3]) }\n"
"  first_(params) {\n"
"    var res = fetch_(\"%(this) LIMIT 1\", params)\n"
"    return res is List && res.count > 0 ? res[0] : null\n"
"  }\n"
"  first { first_([]) }\n"
"  first() { first_([]) }\n"
"  first(param) { first_(param is List ? param : [param]) }\n"
"  first(p1, p2) { first_([p1, p2]) }\n"
"  first(p1, p2, p3) { first_([p1, p2, p3]) }\n"
"  val { val([]) }\n"
"  val() { val([]) }\n"
"  val(param) {\n"
"    var res = first_(param is List ? param : [param])\n"
"    return res is Map ? res.values.join() : null\n"
"  }\n"
"  val(p1, p2) { first_([p1, p2]).values.join() }\n"
"  val(p1, p2, p3) { first_([p1, p2, p3]).values.join() }\n"
"  toNum { Num.fromString(val) }\n"
"  toNum(param) { Num.fromString(val(param)) }\n"
"  toNum(p1, p2) { Num.fromString(val(p1, p2)) }\n"
"  toNum(p1, p2, p3) { Num.fromString(val(p1, p2, p3)) }\n"
"  toBool { toNum != 0 }\n"
"  toBool(param) { toNum(param) != 0 }\n"
"  toBool(p1, p2) { toNum(p1, p2) != 0 }\n"
"  toBool(p1, p2, p3) { toNum(p1, p2, p3) != 0 }\n"
"}\n";
