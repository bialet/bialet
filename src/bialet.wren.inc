// Generated automatically from ./src/bialet.wren. Do not edit.
static const char* bialetModuleSource =
"class Request {\n"
"  static init(message, route, files) {\n"
"    __message = message\n"
"    __headers = {}\n"
"    __get = {}\n"
"    __post = {}\n"
"    __files = files\n"
"    var lines = message.split(\"\\n\")\n"
"    var tmp = lines.removeAt(0).split(\" \")\n"
"    __method = tmp[0]\n"
"    __fullUri = tmp[1]\n"
"    __body = \"\"\n"
"    __route = __fullUri.trimStart(route.trimEnd(\"#\")).split(\"/\")\n"
"    var uriSeparator = __fullUri.indexOf(\"?\")\n"
"    if (uriSeparator > 0) {\n"
"      __uri = __fullUri[0...uriSeparator]\n"
"      __get = parseQuery(__fullUri[uriSeparator+1...__fullUri.count])\n"
"    }\n"
"    var startBody = false\n"
"    var headerName\n"
"    var headerValue\n"
"    for (line in lines) {\n"
"      if (line.trim() == \"\") {\n"
"        startBody = true\n"
"        continue\n"
"      }\n"
"      if (!startBody) {\n"
"        tmp = line.split(\":\")\n"
"        headerName = tmp.removeAt(0).trim().lower\n"
"        headerValue = tmp.join(\":\").trim()\n"
"        if (headerName == \"cookie\") {\n"
"          Cookie.parseHeader(headerValue)\n"
"        }\n"
"        __headers[headerName] = headerValue\n"
"      } else {\n"
"        __body = __body + line\n"
"      }\n"
"    }\n"
"    if (__method.upper == \"POST\") {\n"
"      __post = parseQuery(__body)\n"
"    }\n"
"  }\n"
"  static parseQuery(query) {\n"
"    var all = {}\n"
"    query = query.trim()\n"
"    if (query == \"\") {\n"
"      return all\n"
"    }\n"
"    query.split(\"&\").each{|q|\n"
"      var value = true\n"
"      var tmp = q.split(\"=\")\n"
"      var key = Util.urlDecode(tmp[0])\n"
"      if (tmp.count > 1) {\n"
"        value = Util.urlDecode(tmp[1])\n"
"      }\n"
"      all[key] = value\n"
"    }\n"
"    return all\n"
"  }\n"
"  static method { __method }\n"
"  static uri { __uri }\n"
"  static body { __body }\n"
"  static isPost { __method == \"POST\" }\n"
"  static isJson { header(\"content-type\") == \"application/json\" }\n"
"  static header(name) { __headers[name] ? __headers[name]:null }\n"
"  static get(name) { __get[name] ? __get[name]:null }\n"
"  static post(name) { __post[name] ? __post[name]:null }\n"
"  static route(pos) { __route.count > pos && __route[pos] != \"\" ? __route[pos]:null}\n"
"  static file(name) {\n"
"    var res = Query.fetchFromString(\"SELECT * FROM BIALET_FILES WHERE name = ? AND id IN (%(__files))\", [name])\n"
"    if (res.count == 0) return null\n"
"    return File.new(res[0]).save\n"
"  }\n"
"}\n"
"class Response {\n"
"  static init {\n"
"    __headers = {\"Content-Type\": \"text/html; charset=UTF-8\"}\n"
"    __cookies = []\n"
"    __status = 200\n"
"    __out = \"\"\n"
"    Cookie.init\n"
"  }\n"
"  static out { __out.trim() }\n"
"  static status { __status }\n"
"  static headers { __cookies.join(\"\\r\\n\") +  __headers.keys.map{|k| k + \": \" + __headers[k] + \"\\r\\n\"}.join() }\n"
"  static out(out) { __out = __out + \"\\r\\n\" + out }\n"
"  static status(status) { __status = status }\n"
"  static addCookieHeader(value) { __cookies.add(\"Set-Cookie: %(value)\") }\n"
"  static header(header, value) { __headers[header.trim()] = value.trim() }\n"
"  static file(id) {\n"
"    var type = `SELECT type FROM BIALET_FILES WHERE id = ?`.val([id])\n"
"    if (!type) return false\n"
"    __out = String.fromByte(26) + \"%(id)\"\n"
"    header(\"Content-Type\", type)\n"
"    return true\n"
"  }\n"
"  static json(data) {\n"
"    header(\"Content-Type\", \"application/json; charset=UTF-8\")\n"
"    out(Json.stringify(data))\n"
"  }\n"
"  static page(title, message) { '<!DOCTYPE html><body style=\"font:2.3rem system-ui;text-align:center;margin:2em;color:#024\"><h1>%( title )</h1><p>%( message )</p><p style=\"font-size:.8em;margin-top:2em\">Powered by üö≤ <b><a href=\"https://bialet.dev\" style=\"color:#007FAD\" >Bialet' }\n"
"  static end(code, title, message) { status(code) && out(page(title, message)) }\n"
"  static redirect(url) {\n"
"    header(\"Location\", url)\n"
"    return end(302, \"‚û°Ô∏è Redirect to\", '<a href=\"%(url)\">%(url)</a>')\n"
"  }\n"
"  static forbidden() { end(403, \"üö´ Forbidden\", \"Sorry, you don't have permission to access this page\") }\n"
"  static login() {\n"
"    header(\"WWW-Authenticate\", 'Basic realm=\"Login required\"')\n"
"    return end(401, \"üîí Needs login\", '<a href=\"javascript:location.reload()\">Sign in</a> to access this page')\n"
"  }\n"
"}\n"
"class Cookie {\n"
"  static init { __cookies = {} }\n"
"  static parseHeader(headerValue) {\n"
"    __cookies = {}\n"
"    for (cookieStr in headerValue.split(\";\")) {\n"
"      var cookie = cookieStr.split(\"=\")\n"
"      if (cookie.count > 1) {\n"
"        __cookies[cookie[0].trim()] = cookie[1].trim()\n"
"      }\n"
"    }\n"
"  }\n"
"  static set(name, value, options) {\n"
"    Response.addCookieHeader(\"%(name)=%(value); %( options.keys.map{|k| \"%(k)=%(options[k])\"}.join(\"; \") )\")\n"
"    __cookies[name] = value\n"
"  }\n"
"  static set(name, value){ set(name, value, {}) }\n"
"  static delete(name){ set(name, \"\", {\"expires\": \"Thu, 01 Jan 1970 00:00:00 GMT\"}) }\n"
"  static get(name, default){ __cookies != null && __cookies[name] ? __cookies[name]: default }\n"
"  static get(name){ get(name, null) }\n"
"}\n"
"class Session {\n"
"  static name { __name ? __name : \"BIALETSESSID\" }\n"
"  static name=(n) { __name = n }\n"
"  static destroy() {\n"
"    var id = Cookie.get(Session.name)\n"
"    Cookie.delete(Session.name)\n"
"    `DELETE FROM BIALET_SESSION WHERE id = ? OR updatedAt < date('now', '-1 month')`.query([id])\n"
"  }\n"
"  construct new() {\n"
"    _id = Cookie.get(Session.name)\n"
"    if (!_id) {\n"
"      _id = Util.randomString(40)\n"
"      Cookie.set(Session.name, _id)\n"
"    }\n"
"    __values = {}\n"
"    var res = `SELECT key, val FROM BIALET_SESSION WHERE id = ?`.fetch([_id])\n"
"    if (res && res.count > 0) {\n"
"      res.each{|r| __values[r[\"key\"]] = r[\"val\"] }\n"
"    }\n"
"  }\n"
"  static id { Session.new().id }\n"
"  id { _id }\n"
"  get(key) { __values[key] ? __values[key] : null }\n"
"  set(key, value) {\n"
"    __values[key] = value\n"
"    `REPLACE INTO BIALET_SESSION (id, key, val, updatedAt) VALUES (?, ?, ?, CURRENT_TIMESTAMP)`.query(_id, key, \"%(value)\")\n"
"  }\n"
"  csrf {\n"
"    var token = Util.randomString(60)\n"
"    set(\"_bialet_csrf\", token)\n"
"    return '<input type=\"hidden\" name=\"_bialet_csrf\" value=\"%( token )\">'\n"
"  }\n"
"  csrfOk { get(\"_bialet_csrf\") == Request.post(\"_bialet_csrf\") }\n"
"}\n"
"class Json {\n"
"  static parse(string) {\n"
"    return JsonParser.new(string).parse\n"
"  }\n"
"  static stringify(object) {\n"
"    return JsonStringifier.new(object).toString\n"
"  }\n"
"  static tokenize(string) {\n"
"    return JsonScanner.new(string).tokenize\n"
"  }\n"
"}\n"
"class JsonStringifier {\n"
"  construct new(object) {\n"
"    _object = object\n"
"  }\n"
"  toString { stringify(_object) }\n"
"  stringify(obj) {\n"
"    if (obj is Null) {\n"
"      return \"null\"\n"
"    }\n"
"    if (obj is Num || obj is Bool) {\n"
"      return obj.toString\n"
"    } else if (obj is String) {\n"
"      var substrings = []\n"
"      for (char in obj) {\n"
"        if (char == \"\\\"\") {\n"
"          substrings.add(\"\\\\\\\"\")\n"
"        } else if (char == \"\\\\\") {\n"
"          substrings.add(\"\\\\\\\\\")\n"
"        } else if (char == \"\\b\") {\n"
"          substrings.add(\"\\\\b\")\n"
"        } else if (char == \"\\f\") {\n"
"          substrings.add(\"\\\\f\")\n"
"        } else if (char == \"\\n\") {\n"
"          substrings.add(\"\\\\n\")\n"
"        } else if (char == \"\\r\") {\n"
"          substrings.add(\"\\\\r\")\n"
"        } else if (char == \"\\t\") {\n"
"          substrings.add(\"\\\\t\")\n"
"        } else if (char.bytes[0] <= 0x1f) {\n"
"          var byte = char.bytes[0]\n"
"          var hex = Util.lpad(Util.toHex(byte), 4, \"0\")\n"
"          substrings.add(\"\\\\u\" + hex)\n"
"        } else {\n"
"          substrings.add(char)\n"
"        }\n"
"      }\n"
"      return \"\\\"\" + substrings.join(\"\") + \"\\\"\"\n"
"    } else if (obj is List) {\n"
"      var substrings = obj.map { |o| stringify(o) }\n"
"      return \"[\" + substrings.join(\",\") + \"]\"\n"
"    } else if (obj is Map) {\n"
"      var substrings = obj.keys.map { |key|\n"
"        return stringify(key) + \":\" + stringify(obj[key])\n"
"      }\n"
"      return \"{\" + substrings.join(\",\") + \"}\"\n"
"    }\n"
"  }\n"
"}\n"
"class JsonParser {\n"
"  construct new(input) {\n"
"    _input = input\n"
"    _tokens = []\n"
"  }\n"
"  valueTypes { [JsonToken.String, JsonToken.Number, JsonToken.Bool, JsonToken.Null] }\n"
"  parse { nest(JsonScanner.new(_input).tokenize) }\n"
"  nest(tokens) {\n"
"    if (tokens.count == 0) { parsingError }\n"
"    var token = tokens.removeAt(0)\n"
"    if (token.type == JsonToken.LeftBrace) {\n"
"      var map = {}\n"
"      while (tokens[0].type != JsonToken.RightBrace) {\n"
"        var key = tokens.removeAt(0)\n"
"        if (key.type != JsonToken.String) { parsingError(key) }\n"
"        var next = tokens.removeAt(0)\n"
"        if (next.type != JsonToken.Colon) { parsingError(next) }\n"
"        var value = nest(tokens)\n"
"        map[key.value] = value\n"
"        if (tokens.count >= 2 &&\n"
"            tokens[0].type == JsonToken.Comma &&\n"
"            tokens[1].type != JsonToken.RightBrace) {\n"
"          tokens.removeAt(0)\n"
"        }\n"
"      }\n"
"      tokens.removeAt(0)\n"
"      return map\n"
"    } else if (token.type == JsonToken.LeftBracket) {\n"
"      var list = []\n"
"      while (tokens[0].type != JsonToken.RightBracket) {\n"
"        list.add(nest(tokens))\n"
"        if (tokens[0].type == JsonToken.Comma) {\n"
"          tokens.removeAt(0)\n"
"        }\n"
"      }\n"
"      tokens.removeAt(0)\n"
"      return list\n"
"    } else if (valueTypes.contains(token.type)) {\n"
"      return token.value\n"
"    } else { parsingError(token) }\n"
"  }\n"
"  parsingError (token) {\n"
"    var position = Util.getPositionForIndex(_input, token.index)\n"
"    invalidJson(\"Unexpected \\\"%(token)\\\" at line %(position[\"line\"]), column %(position[\"column\"])\")\n"
"  }\n"
"  parsingError {\n"
"    invalidJson(\"\")\n"
"  }\n"
"  invalidJson(message) {\n"
"    var base = \"Invalid Json\"\n"
"    Fiber.abort(message.count > 0 ? \"%(base): %(message)\" : base)\n"
"  }\n"
"}\n"
"class JsonScanner {\n"
"  construct new(input) {\n"
"    _input = input\n"
"    _tokens = []\n"
"    _start = 0\n"
"    _cursor = 0\n"
"  }\n"
"  numberChars { \"0123456789.-\" }\n"
"  whitespaceChars { \" \\r\\t\\n\"}\n"
"  escapedCharMap {\n"
"    return {\n"
"      \"\\\"\": \"\\\"\",\n"
"      \"\\\\\": \"\\\\\",\n"
"      \"b\": \"\\b\",\n"
"      \"f\": \"\\f\",\n"
"      \"n\": \"\\n\",\n"
"      \"r\": \"\\r\",\n"
"      \"t\": \"\\t\"\n"
"    }\n"
"  }\n"
"  tokenize {\n"
"    while (!isAtEnd()) {\n"
"      _start = _cursor\n"
"      scanToken()\n"
"    }\n"
"    addToken(JsonToken.End)\n"
"    return _tokens\n"
"  }\n"
"  scanToken () {\n"
"    var char = advance()\n"
"    if (char == \"{\") {\n"
"      addToken(JsonToken.LeftBrace)\n"
"    } else if (char == \"}\") {\n"
"      addToken(JsonToken.RightBrace)\n"
"    } else if (char == \"[\") {\n"
"      addToken(JsonToken.LeftBracket)\n"
"    } else if (char == \"]\") {\n"
"      addToken(JsonToken.RightBracket)\n"
"    } else if (char == \":\") {\n"
"      addToken(JsonToken.Colon)\n"
"    } else if (char == \",\") {\n"
"      addToken(JsonToken.Comma)\n"
"    } else if (char == \"/\") {\n"
"      scanningError\n"
"    } else if (char == \"\\\"\") {\n"
"      scanString()\n"
"    } else if (numberChars.contains(char)) {\n"
"      scanNumber()\n"
"    } else if (isAlpha(char)) {\n"
"      scanIdentifier()\n"
"    } else if (whitespaceChars.contains(char)) {\n"
"    } else {\n"
"      scanningError\n"
"    }\n"
"  }\n"
"  scanString () {\n"
"    var isEscaping = false\n"
"    var valueInProgress = []\n"
"    while ((peek() != \"\\\"\" || isEscaping) && !isAtEnd()) {\n"
"      var char = advance()\n"
"      if (isEscaping) {\n"
"        if (escapedCharMap.containsKey(char)) {\n"
"          valueInProgress.add(escapedCharMap[char])\n"
"        } else if (char == \"u\") { // unicode char!\n"
"          var charsToPull = 4\n"
"          var start = _cursor\n"
"          var hexString = _input.slice(start, start + charsToPull).join(\"\")\n"
"          var decimal = Util.hexToDec(hexString)\n"
"          if (decimal == null) scanningError\n"
"          valueInProgress.add(String.fromCodePoint(decimal))\n"
"          _cursor = _cursor + charsToPull\n"
"        } else {\n"
"          scanningError\n"
"        }\n"
"        isEscaping = false\n"
"      } else if (char == \"\\\\\") {\n"
"        isEscaping = true\n"
"      } else {\n"
"        valueInProgress.add(char)\n"
"      }\n"
"    }\n"
"    if (isAtEnd()) {\n"
"      scanningError\n"
"      return\n"
"    }\n"
"    advance()\n"
"    addToken(JsonToken.String, valueInProgress.join(\"\"))\n"
"  }\n"
"  scanNumber () {\n"
"    var value = String.fromCodePoint(_input.codePoints[_cursor - 1])\n"
"    while (numberChars.contains(peek())) {\n"
"      value = \"%( value )%( advance() )\"\n"
"    }\n"
"    var number = Num.fromString(value)\n"
"    if (number == null) {\n"
"      scanningError\n"
"    } else {\n"
"      addToken(JsonToken.Number, number)\n"
"    }\n"
"  }\n"
"  scanIdentifier () {\n"
"    var value = String.fromCodePoint(_input.codePoints[_cursor - 1])\n"
"    while (isAlpha(peek())) {\n"
"      value = \"%( value )%( advance() )\"\n"
"    }\n"
"    if (value == \"true\") {\n"
"      addToken(JsonToken.Bool, true)\n"
"    } else if (value == \"false\") {\n"
"      addToken(JsonToken.Bool, false)\n"
"    } else if (value == \"null\") {\n"
"      addToken(JsonToken.Null, null)\n"
"    } else {\n"
"      scanningError\n"
"    }\n"
"  }\n"
"  advance () {\n"
"    _cursor = _cursor + 1\n"
"    return String.fromCodePoint(_input.codePoints[_cursor - 1])\n"
"  }\n"
"  isAlpha (char) {\n"
"    var pt = char.codePoints[0]\n"
"    return (pt >= \"a\".codePoints[0] && pt <= \"z\".codePoints[0]) ||\n"
"           (pt >= \"A\".codePoints[0] && pt <= \"Z\".codePoints[0])\n"
"  }\n"
"  isAtEnd () {\n"
"    return _cursor >= _input.bytes.count\n"
"  }\n"
"  peek () {\n"
"    if (_input.codePoints[_cursor] < 0) { _cursor = _cursor + 1 }\n"
"    if (isAtEnd()) return \"\\0\"\n"
"    return String.fromCodePoint(_input.codePoints[_cursor])\n"
"  }\n"
"  addToken(type) { addToken(type, null) }\n"
"  addToken(type, value) { _tokens.add(JsonToken.new(type, value, _cursor)) }\n"
"  scanningError {\n"
"    var value = _input.slice(_start, _cursor).join(\"\")\n"
"    var position = Util.getPositionForIndex(_input, _start)\n"
"    Fiber.abort(\"Invalid JSON: Unexpected \\\"%(value)\\\" at line %(position[\"line\"]), column %(position[\"column\"])\")\n"
"  }\n"
"}\n"
"class JsonToken {\n"
"  static LeftBracket { \"LEFT_BRACKET\" }\n"
"  static RightBracket { \"RIGHT_BRACKET\" }\n"
"  static LeftBrace { \"LEFT_BRACE\" }\n"
"  static RightBrace { \"RIGHT_BRACE\" }\n"
"  static Colon { \"COLON\" }\n"
"  static Comma { \"COMMA\" }\n"
"  static String { \"STRING\" }\n"
"  static Number { \"NUMBER\" }\n"
"  static Bool { \"BOOL\" }\n"
"  static Null { \"NULL\"}\n"
"  static End { \"EOF\"}\n"
"  construct new(type, value, index) {\n"
"    _type = type\n"
"    _value = value\n"
"    _index = index\n"
"  }\n"
"  toString {\n"
"    return (_value != null) ? (_type + \" \" + _value.toString) : _type\n"
"  }\n"
"  type { _type }\n"
"  value { _value }\n"
"  index { _index }\n"
"}\n"
"var HEX_CHARS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n"
"var BASE64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n"
"class Util {\n"
"  static randomString(length) { randomString_(toNum(length)) }\n"
"  static hash(password) { hash_(\"%( password )\") }\n"
"  static verify(password, hash) { verify_(\"%( password )\", \"%( hash )\") }\n"
"  static toNum(val) {\n"
"    if (!val) return 0\n"
"    if (val is Num) return val\n"
"    val = Num.fromString(\"%(val)\")\n"
"    if (!val) return 0\n"
"    return val\n"
"  }\n"
"  static hexToDec(hexStr) {\n"
"    var decimal = 0\n"
"    var length = hexStr.count\n"
"    var base = 1 // Initialize base value to 1, i.e., 16^0\n"
"    for (i in (length - 1)..0) {\n"
"      var char = hexStr[i].bytes[0]\n"
"      var value = 0\n"
"      if (char >= \"0\".bytes[0] && char <= \"9\".bytes[0]) {\n"
"        value = char - \"0\".bytes[0]\n"
"      } else if (char >= \"A\".bytes[0] && char <= \"F\".bytes[0]) {\n"
"        value = char - \"A\".bytes[0] + 10\n"
"      } else if (char >= \"a\".bytes[0] && char <= \"f\".bytes[0]) {\n"
"        value = char - \"a\".bytes[0] + 10\n"
"      }\n"
"      decimal = decimal + value * base\n"
"      base = base * 16\n"
"    }\n"
"    return decimal\n"
"  }\n"
"  static toHex(byte) {\n"
"    var hex = \"\"\n"
"    while (byte > 0) {\n"
"      var c = byte % 16\n"
"      hex = HEX_CHARS[c] + hex\n"
"      byte = byte >> 4\n"
"    }\n"
"    return hex\n"
"  }\n"
"  static urlDecode(str) {\n"
"    var decoded = \"\"\n"
"    var i = 0\n"
"    while (i < str.count) {\n"
"      if (str[i] == \"\\%\") {\n"
"        var hex = str[i + 1..i + 2]\n"
"        var charCode = hexToDec(hex)\n"
"        decoded = decoded + String.fromByte(charCode)\n"
"        i = i + 3\n"
"      } else if (str[i] == \"+\") {\n"
"        decoded = decoded + \" \"\n"
"        i = i + 1\n"
"      } else {\n"
"        decoded = decoded + str[i]\n"
"        i = i + 1\n"
"      }\n"
"    }\n"
"    return decoded\n"
"  }\n"
"  static urlEncode(str) {\n"
"    var encoded = \"\"\n"
"    str = \"%(str)\"\n"
"    for (char in str) {\n"
"      if (char == \" \") {\n"
"        encoded = encoded + \"+\"\n"
"      } else if (char == \"\\%\") {\n"
"        encoded = encoded + \"\\%25\"\n"
"      } else if (char == \"&\") {\n"
"        encoded = encoded + \"\\%26\"\n"
"      } else if (char == \"=\") {\n"
"        encoded = encoded + \"\\%3D\"\n"
"      } else if (char == \"?\") {\n"
"        encoded = encoded + \"\\%3F\"\n"
"      } else {\n"
"        encoded = encoded + char\n"
"      }\n"
"    }\n"
"    return encoded\n"
"  }\n"
"  static params(params) {\n"
"    var result = \"\"\n"
"    var first = true\n"
"    for (entry in params) {\n"
"      if (!first) {\n"
"        result = result + \"&\"\n"
"      }\n"
"      result = result + urlEncode(entry.key) + \"=\" + urlEncode(entry.value)\n"
"      first = false\n"
"    }\n"
"    return result\n"
"  }\n"
"  static lpad(s, count, with) {\n"
"    while (s.count < count) {\n"
"      s = \"%(with)%(s)\"\n"
"    }\n"
"    return s\n"
"  }\n"
"  static reverse(str) {\n"
"    var result = \"\"\n"
"    for (char in str) {\n"
"      result = char + result\n"
"    }\n"
"    return result\n"
"  }\n"
"  static getPositionForIndex(text, index) {\n"
"    var precedingText = text.slice(0, index)\n"
"    var linebreaks = precedingText.where {|char| char == \"\\n\"}\n"
"    var reversedPreceding = Util.reverse(precedingText)\n"
"    var hasSeenLinebreak = false\n"
"    var i = 0\n"
"    while (i < reversedPreceding.count && !hasSeenLinebreak) {\n"
"      if (reversedPreceding[i] == \"\\n\") {\n"
"        hasSeenLinebreak = true\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    return {\n"
"      \"line\": linebreaks.count,\n"
"      \"column\": i\n"
"    }\n"
"  }\n"
"  static encodeBase64(input) {\n"
"    var encoded = \"\"\n"
"    var i = 0\n"
"    while (i < input.count) {\n"
"      i = i + 1\n"
"      var b1 = input.byteAt(i) & 0xFF\n"
"      if (i == input.count) {\n"
"        encoded = encoded + BASE64_CHARS[b1 >> 2]\n"
"        encoded = encoded + BASE64_CHARS[(b1 & 0x3) << 4]\n"
"        encoded = encoded + \"==\"\n"
"        break\n"
"      }\n"
"      i = i + 1\n"
"      var b2 = input.byteAt(i) & 0xFF\n"
"      if (i == input.count) {\n"
"        encoded = encoded + BASE64_CHARS[b1 >> 2]\n"
"        encoded = encoded + BASE64_CHARS[((b1 & 0x3) << 4) | ((b2 & 0xF0) >> 4)]\n"
"        encoded = encoded + BASE64_CHARS[(b2 & 0xF) << 2]\n"
"        encoded = encoded + \"=\"\n"
"        break\n"
"      }\n"
"      i = i + 1\n"
"      var b3 = input.byteAt(i) & 0xFF\n"
"      encoded = encoded + BASE64_CHARS[b1 >> 2]\n"
"      encoded = encoded + BASE64_CHARS[((b1 & 0x3) << 4) | ((b2 & 0xF0) >> 4)]\n"
"      encoded = encoded + BASE64_CHARS[((b2 & 0xF) << 2) | ((b3 & 0xC0) >> 6)]\n"
"      encoded = encoded + BASE64_CHARS[b3 & 0x3F]\n"
"    }\n"
"    return encoded\n"
"  }\n"
"  static decodeBase64(input) {\n"
"    var decoded = \"\"\n"
"    var i = 0\n"
"    while (i < input.count) {\n"
"      var b1 = BASE64_CHARS.indexOf(input[i])\n"
"      i = i + 1\n"
"      var b2 = BASE64_CHARS.indexOf(input[i])\n"
"      i = i + 1\n"
"      var b3 = BASE64_CHARS.indexOf(input[i])\n"
"      i = i + 1\n"
"      var b4 = BASE64_CHARS.indexOf(input[i])\n"
"      i = i + 1\n"
"      decoded = decoded + String.fromByte((b1 << 2) | (b2 >> 4))\n"
"      if (b3 != -1) {\n"
"        decoded = decoded + String.fromByte(((b2 & 0xF) << 4) | (b3 >> 2))\n"
"        if (b4 != -1) {\n"
"          decoded = decoded + String.fromByte(((b3 & 0x3) << 6) | b4)\n"
"        }\n"
"      }\n"
"    }\n"
"    return decoded\n"
"  }\n"
"}\n"
"class Config {\n"
"  static get(key) { `SELECT val FROM BIALET_CONFIG WHERE key = ?`.first([key])[\"val\"].toString }\n"
"  static set(key, value) { `REPLACE INTO BIALET_CONFIG (key, val) VALUES (?, ?)`.query(key, value) }\n"
"  static bool(key) { get(key) != \"0\" }\n"
"  static num(key) { Num.fromString(get(key)) }\n"
"  static delete(key) { `DELETE FROM BIALET_CONFIG WHERE key = ?`.first(key) }\n"
"  static json(key) { set(key, Json.parse(get(key))) }\n"
"  static json(key, val) { set(key, Json.stringify(val)) }\n"
"}\n"
"class File {\n"
"  construct new(data) { set_(data) }\n"
"  construct get(id) { set_(`SELECT * FROM BIALET_FILES WHERE id = ? AND isTemp = 0`.first([id])) }\n"
"  construct create(name, type, file, size) { create_(name, type, file, size) }\n"
"  construct create(name, type, file) { create_(name, type, file, file.count) }\n"
"  create_(name, type, file, size) {\n"
"    var id = `INSERT INTO BIALET_FILES (name, originalFileName, type, file, size, isTemp) VALUES (?, ?, ?, ?, ?, 0)`.query([name, name, type, file, size])\n"
"    _name = name\n"
"    _id = id\n"
"    _type = type\n"
"    _size = size\n"
"    _file = file\n"
"    _isTemp = false\n"
"    _createdAt = null\n"
"  }\n"
"  set_(f) {\n"
"    if (!f) {\n"
"      _name = null\n"
"      _id = null\n"
"      _type = null\n"
"      _size = null\n"
"      _file = null\n"
"      _isTemp = false\n"
"      _createdAt = null\n"
"      return\n"
"    }\n"
"    _name = f[\"originalFileName\"]\n"
"    _id = f[\"id\"]\n"
"    _type = f[\"type\"]\n"
"    _size = Num.fromString(\"%(f[\"size\"])\")\n"
"    _createdAt = f[\"createdAt\"]\n"
"    _isTemp = f[\"isTemp\"] == \"0\"\n"
"  }\n"
"  id { _id }\n"
"  type { _type }\n"
"  name { _name }\n"
"  size { _size }\n"
"  isTemp { _isTemp }\n"
"  createdAt { _createdAt }\n"
"  destroy { `DELETE FROM BIALET_FILES WHERE id = ? LIMIT 1`.query(_id) }\n"
"  destroy() { destroy }\n"
"  save {\n"
"    _isTemp = false\n"
"    `UPDATE BIALET_FILES SET isTemp = 0 WHERE id = ? LIMIT 1`.query(_id)\n"
"    return this\n"
"  }\n"
"  save() { save }\n"
"  temp {\n"
"    _isTemp = true\n"
"    `UPDATE BIALET_FILES SET isTemp = 1 WHERE id = ? LIMIT 1`.query(_id)\n"
"    return this\n"
"  }\n"
"  temp() { temp }\n"
"}\n"
"class Db {\n"
"  static init {\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_LOGS (message TEXT, createdAt DATETIME DEFAULT CURRENT_TIMESTAMP)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_MIGRATIONS (version TEXT, createdAt DATETIME DEFAULT CURRENT_TIMESTAMP)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_SESSION (id TEXT, key TEXT, val TEXT, updatedAt DATETIME)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_CONFIG (key TEXT PRIMARY KEY, val TEXT)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_USERS (id INTEGER PRIMARY KEY, email TEXT, password TEXT,\n"
"    name TEXT, isAdmin INTEGER, createdAt DATETIME DEFAULT CURRENT_TIMESTAMP, updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_FILES (id INTEGER PRIMARY KEY, name TEXT, originalFileName TEXT, type TEXT, size INTEGER, file BLOB, isTemp INTEGER DEFAULT 1, createdAt DATETIME DEFAULT CURRENT_TIMESTAMP)`.query()\n"
"    `CREATE TABLE IF NOT EXISTS BIALET_IMPORT (module TEXT PRIMARY KEY, content TEXT, createdAt DATETIME DEFAULT CURRENT_TIMESTAMP)`.query()\n"
"  }\n"
"  static clean {\n"
"    `DELETE FROM BIALET_SESSION WHERE updatedAt < date('now', '-1 year')`.query()\n"
"    `DELETE FROM BIALET_FILES WHERE isTemp = 1 AND createdAt < date('now', '-1 day')`.query()\n"
"  }\n"
"  static migrate(version, schema) {\n"
"    Db.init\n"
"    if (!`SELECT version FROM BIALET_MIGRATIONS WHERE version = ?`.first([version])) {\n"
"      schema.toString.split(\";\").each{|q| Query.fromString(q, []) }\n"
"      `INSERT INTO BIALET_MIGRATIONS (version) VALUES (?)`.query([version])\n"
"    }\n"
"    Db.clean\n"
"  }\n"
"  static save(table, values) {\n"
"    var keys = []\n"
"    var bind = []\n"
"    var params = []\n"
"    var v\n"
"    for (val in values) {\n"
"      v = val\n"
"      if (v is MapEntry) {\n"
"        v = val.value\n"
"        keys.add(val.key)\n"
"      }\n"
"      if (v is Date) v = v.toString.replace(\"T\", \" \")\n"
"      if (v is Query) {\n"
"        bind.add(v.toString)\n"
"      } else {\n"
"        bind.add(\"?\")\n"
"        params.add(v)\n"
"      }\n"
"    }\n"
"    var k = keys.count > 0 ? \"(%(keys.join(\",\")))\" : \"\"\n"
"    return Query.fromString(\"REPLACE INTO `%(table)` %(k) VALUES (%(bind.join(',')))\", params)\n"
"  }\n"
"  static delete(table, id) { Query.fromString(\"DELETE FROM `%(table)` WHERE id = ?\", [id]) }\n"
"}\n"
"class Http {\n"
"  construct new() {\n"
"    _method = false\n"
"    _basicAuth = \"\"\n"
"    _status = 0\n"
"    _headers = {}\n"
"    _body = \"\"\n"
"    _error = 0\n"
"    _fullHeaders = \"\"\n"
"    _postData = \"\"\n"
"  }\n"
"  body { _body }\n"
"  status { _status }\n"
"  headers { _headers }\n"
"  headers(name) { _headers.containsKey(name) ? _headers[name] : null }\n"
"  error { _error }\n"
"  method { _method }\n"
"  method=(m) { _method = m }\n"
"  postData=(data) {\n"
"    if (!_method) {\n"
"      _method = \"POST\"\n"
"    }\n"
"    _postData = data ? (data is String ? data : Json.stringify(data)) : \"\"\n"
"  }\n"
"  call(url, options) {\n"
"    if (!_method) {\n"
"      _method = \"GET\"\n"
"    }\n"
"    if (!options.containsKey(\"headers\")) {\n"
"      options[\"headers\"] = {}\n"
"    }\n"
"    if (!options[\"headers\"].containsKey(\"Content-Type\")) {\n"
"      options[\"headers\"][\"Content-Type\"] = \"application/json\"\n"
"    }\n"
"    var headers = options[\"headers\"].map{|h| \"%(h.key): %(h.value)\" }.join(\"\\n\")\n"
"    if (options[\"basicAuth\"] != null) {\n"
"      _basicAuth = options[\"basicAuth\"][\"username\"] + \":\" + options[\"basicAuth\"][\"password\"]\n"
"    }\n"
"    var response = call_(url, _method, headers, _postData, _basicAuth)\n"
"    if (response[1]) {\n"
"      var lines = response[1].split(\"\\n\")\n"
"      var tmp\n"
"      var headerName\n"
"      var headerValue\n"
"      for (line in lines) {\n"
"        tmp = line.split(\":\")\n"
"        headerName = tmp.removeAt(0).trim().lower\n"
"        headerValue = tmp.join(\":\").trim().lower\n"
"        _headers[headerName] = headerValue\n"
"      }\n"
"    }\n"
"    _status = response[0]\n"
"    _fullHeaders = response[1].trim()\n"
"    _body = response[2].trim()\n"
"    _error = response[3]\n"
"    return _error == 0\n"
"  }\n"
"  static request(url, method, data, options) {\n"
"    __http = Http.new()\n"
"    __http.method = method\n"
"    __http.postData = data\n"
"    if (!__http.call(url, options)) {\n"
"      return false\n"
"    }\n"
"    if (__http.status >= 200 && __http.status < 300) {\n"
"      if (__http.headers(\"content-type\").contains(\"text/json\") || __http.headers(\"content-type\").contains(\"application/json\")) {\n"
"        return Json.parse(__http.body)\n"
"      } else {\n"
"        return __http.body\n"
"      }\n"
"    }\n"
"  }\n"
"  static get(url, options) { request(url, \"GET\", null, options) }\n"
"  static post(url, data, options) { request(url, \"POST\", data, options) }\n"
"  static put(url, data, options) { request(url, \"PUT\", data, options) }\n"
"  static delete(url, options) { request(url, \"DELETE\", null, options) }\n"
"  static get(url) { get(url, {}) }\n"
"  static post(url, data) { post(url, data, {}) }\n"
"  static post(url) { post(url, \"\", {}) }\n"
"  static put(url, data) { put(url, data, {}) }\n"
"  static put(url) { put(url, \"\", {}) }\n"
"  static delete(url) { delete(url, {}) }\n"
"}\n"
"class Date {\n"
"  static init {\n"
"    __tz = null\n"
"  }\n"
"  static tz {\n"
"    if (__tz is Null) {\n"
"       __tz = Config.get(\"BIALET_TIMEZONE\") \n"
"    }\n"
"    return __tz\n"
"  }\n"
"  static fromString(date) { Date.fromString(date, Date.tz) }\n"
"  construct fromString(date, tz) {\n"
"    _tz = tz\n"
"    var f = date.split(\" \")\n"
"    var d = f[0].split(\"-\")\n"
"    var t = (f.count > 1 ? f[1] : \"00:00:00\").split(\":\")\n"
"    _seconds = t[2].toNum\n"
"    _minutes = t[1].toNum\n"
"    _hours = t[0].toNum\n"
"    _day = d[2].toNum\n"
"    _month = d[1].toNum\n"
"    _year = d[0].toNum\n"
"  }\n"
"  construct new(year, month, day, hours, minutes, seconds, tz) {\n"
"    _tz = tz\n"
"    _year = toNum_(year)\n"
"    _month = toNum_(month)\n"
"    _day = toNum_(day)\n"
"    _hours = toNum_(hours)\n"
"    _minutes = toNum_(minutes)\n"
"    _seconds = toNum_(seconds)\n"
"  }\n"
"  static new() { Date.fromString(Date.current_(Date.tz), Date.tz) }\n"
"  static new(date) { Date.new(date, Date.tz) }\n"
"  static new(date, tz) { date is Date ? date : Date.fromString(date, tz) }\n"
"  static new(year, month, day, hours, minutes, seconds) { Date.new(year, month, day, hours, minutes, seconds, Date.tz) }\n"
"  static new(year, month, day) { Date.new(year, month, day, 0, 0, 0, Date.tz) }\n"
"  static new(year, month, day, tz) { Date.new(year, month, day, 0, 0, 0, tz) }\n"
"  static now { Date.new() }\n"
"  toNum_(n) { n is Num ? n : (!n ? 0 : \"%(n)\".toNum) }\n"
"  seconds { _seconds }\n"
"  minutes { _minutes }\n"
"  hours { _hours }\n"
"  day { _day }\n"
"  month { _month }\n"
"  year { _year }\n"
"  tz { _tz }\n"
"  yyyy { _year.toString }\n"
"  yy { _year.toString.substring(2, 4) }\n"
"  mo { _month > 9 ? _month.toString : \"0%(month)\" }\n"
"  dd { _day > 9 ? _day.toString : \"0%(day)\" }\n"
"  hh { _hours > 9 ? _hours.toString : \"0%(hours)\" }\n"
"  mi { _minutes > 9 ? _minutes.toString : \"0%(minutes)\" }\n"
"  ss { _seconds > 9 ? _seconds.toString : \"0%(seconds)\" }\n"
"  dayOfWeek { Date.format_(\"\\%w\", year, month, day, hours, minutes, seconds, tz).toNum }\n"
"  weekOfYear { Date.format_(\"\\%V\", year, month, day, hours, minutes, seconds, tz).toNum }\n"
"  dayOfYear { Date.format_(\"\\%j\", year, month, day, hours, minutes, seconds, tz).toNum }\n"
"  unix { Date.unix_(year, month, day, hours, minutes, seconds, tz) }\n"
"  format(format) { Date.format_(format.replace(\"#\", \"\\%\"), year, month, day, hours, minutes, seconds, tz) }\n"
"  iso { toString }\n"
"  toString { \"%(year)-%(mo)-%(dd) %(hh):%(mi):%(ss)\" }\n"
"  diff(otherDate) { unix - otherDate.unix }\n"
"  cmp_(o) { diff(o) }\n"
"  < (o) { cmp_(o) <  0 }\n"
"  > (o) { cmp_(o) >  0 }\n"
"  <=(o) { cmp_(o) <= 0 }\n"
"  >=(o) { cmp_(o) >= 0 }\n"
"  ==(o) { cmp_(o) == 0 }\n"
"  !=(o) { cmp_(o) != 0 }\n"
"}\n"
"class Cron {\n"
"  static run_(should, job) {\n"
"    if (should) {\n"
"      var res = job.call(__now)\n"
"      System.print(\"Running cron: %(res)\")\n"
"    }\n"
"    return should\n"
"  }\n"
"  static at(hours, minutes, dayOfWeek, job) {\n"
"    if (!__now) __now = Date.now\n"
"    return run_(__now.hours == hours && __now.minutes == minutes && __now.weekday == dayOfWeek, job)\n"
"  }\n"
"  static at(hours, minutes, job) {\n"
"    if (!__now) __now = Date.now\n"
"    return run_(__now.hours == hours && __now.minutes == minutes, job)\n"
"  }\n"
"  static every(minutes, job) {\n"
"    if (!__now) __now = Date.now\n"
"    return run_(__now.minutes % minutes == 0, job)\n"
"  }\n"
"}\n";
